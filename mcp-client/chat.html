<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Chat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        body { margin: 0; display: grid; grid-template-rows: 1fr auto; height: 100dvh; background:#0b0c10; color:#e8e8e8; }
        .chat { padding: 16px; overflow:auto; }
        .msg { max-width: 70ch; margin: 8px 0; padding: 10px 12px; border-radius: 12px; line-height: 1.4; white-space: pre-wrap; }
        .user { margin-left:auto; background:#1f2833; }
        .ai { margin-right:auto; background:#14181f; border:1px solid #252a33; }
        .inputbar { display:flex; gap:8px; padding:12px; border-top:1px solid #252a33; background:#0b0c10; }
        .inputbar input { flex:1; padding:10px 12px; border-radius:10px; border:1px solid #252a33; background:#14181f; color:#e8e8e8; }
        .inputbar button { padding:10px 14px; border-radius:10px; border:1px solid #252a33; background:#14181f; color:#e8e8e8; cursor:pointer; }
        .row { display:flex; gap:8px; align-items:center; }
        .dim { opacity:.7; font-size:.9em; }
    </style>
</head>
<body>
<div id="chat" class="chat"></div>

<form id="form" class="inputbar">
    <div class="row" style="gap:12px; flex:1;">
        <input id="input" placeholder="Type a message…" autocomplete="off" />
        <label class="row dim">
            <input id="streaming" type="checkbox" checked />
            Streaming
        </label>
    </div>
    <button type="submit">Send</button>
    <button id="cancel" type="button" title="Cancel streaming">Cancel</button>
</form>

<script>
    const chatEl = document.getElementById('chat');
    const inputEl = document.getElementById('input');
    const formEl = document.getElementById('form');
    const streamingEl = document.getElementById('streaming');
    const cancelBtn = document.getElementById('cancel');

    // Keep one session id (handy if you later multiplex server-side)
    const sessionId = crypto.randomUUID();

    /** Render helpers */
    function appendBubble(role, text = '') {
        const div = document.createElement('div');
        div.className = `msg ${role === 'user' ? 'user' : 'ai'}`;
        div.textContent = text;
        chatEl.appendChild(div);
        chatEl.scrollTop = chatEl.scrollHeight;
        return div;
    }
    function updateBubbleText(bubble, text) {
        bubble.textContent = text;
        chatEl.scrollTop = chatEl.scrollHeight;
    }

    /** State */
    let currentEventSource = null;
    let currentAbortController = null;

    cancelBtn.onclick = () => {
        if (currentEventSource) currentEventSource.close();
        if (currentAbortController) currentAbortController.abort();
    };

    formEl.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = inputEl.value.trim();
        if (!message) return;
        inputEl.value = '';

        // Show user message
        appendBubble('user', message);

        if (streamingEl.checked) {
            await streamReply(message);
        } else {
            await fetchReply(message);
        }
    });

    async function fetchReply(message) {
        // Simple non-streaming fallback to /chat
        currentAbortController = new AbortController();
        const aiBubble = appendBubble('ai', '…');

        try {
            const resp = await fetch('/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message }),
                signal: currentAbortController.signal
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json(); // { message: "..." }
            updateBubbleText(aiBubble, data.message ?? '');
        } catch (err) {
            updateBubbleText(aiBubble, `❌ ${err.message}`);
        } finally {
            currentAbortController = null;
        }
    }

    async function streamReply(message) {
        // Streaming via SSE to /chat-stream
        const aiBubble = appendBubble('ai', '');
        let buffer = '';

        // Open a per-message SSE stream (simple & robust)
        const url = `http://localhost:8081/chat-stream?message=${encodeURIComponent(message)}&sessionId=${encodeURIComponent(sessionId)}`;
        const es = new EventSource(url);
        currentEventSource = es;

        es.onmessage = (e) => {
            // Server sends token chunks in e.data; we accumulate into a single bubble
            buffer = e.data;
            updateBubbleText(aiBubble, buffer);
        };

        es.addEventListener('done', () => {
            es.close();
            currentEventSource = null;
        });

        es.onerror = (e) => {
            // Network/server error—close out
            es.close();
            currentEventSource = null;
            if (!buffer) updateBubbleText(aiBubble, '❌ Stream error.');
        };
    }
</script>
</body>
</html>
